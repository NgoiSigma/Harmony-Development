class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0

    def parse(self):
        return self.statement_list()

    def statement_list(self):
        statements = []
        while self.current_token() != 'EOF':
            statements.append(self.statement())
            self.next_token()
        return statements

    def statement(self):
        if self.match('тезис'):
            return self.thesis_statement()
        if self.match('антитезис'):
            return self.antithesis_statement()
        if self.match('синтез'):
            return self.synthesis_statement()
        if self.match('анализ'):
            return self.analysis_statement()
        if self.match('прагма'):
            return self.pragma_statement()
        # more statements...
   
    def thesis_statement(self):
        self.consume('тезис')
        identifier = self.consume('IDENTIFIER')
        self.consume('{')
        body = self.statement_list()
        self.consume('}')
        return ThesisNode(identifier, body)

    # Define methods for antithesis, synthesis, analysis, pragma

    def current_token(self):
        return self.tokens[self.pos]

    def next_token(self):
        self.pos += 1

    def match(self, token_type):
        return self.current_token() == token_type

    def consume(self, token_type):
        token = self.current_token()
        self.next_token()
        return token
